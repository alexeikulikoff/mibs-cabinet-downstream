/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package mibs.init.cabinet;



import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Base64;
import java.util.Optional;
import java.util.concurrent.TimeoutException;

import org.apache.commons.lang3.SerializationUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.DeliverCallback;


public class CabinetDownstream extends MessageHandler{
	
	private static final Logger logger = LogManager.getLogger(CabinetDownstream.class.getName());
	private static final int PORT=5672; 
	public CabinetDownstream(String conf) {
		super( conf );
	}
	
	public String getGreeting() {
        return "Hello world.";
    }
	private Optional<Channel> connectToRabbit(String host, String login, String password) {
		ConnectionFactory factory = new ConnectionFactory();
		factory.setHost( host );
		factory.setUsername( login );
		factory.setPassword( password );
		factory.setPort(PORT);
	
		Connection connection;
		Channel channel = null;
		try {
			connection = factory.newConnection();
			channel = connection.createChannel();
		
		} catch (IOException e) {
			logger.error("Error! IO Exception with message: " + e.getMessage());
			exit();
		} catch (TimeoutException e) {
			logger.error("Error! Timeout Exception with message: " + e.getMessage());
			exit();
		}

		return channel != null ? Optional.of(channel) : Optional.empty();

	}
	private void run() {
		Optional<Channel> optionalLocalChannel = connectToRabbit( rabbitmqHost, rabbitmqLogin, rabbitmqPassword );
		if (!optionalLocalChannel.isPresent()) {
			logger.error("Error! Fail to make connection to local rabbitmq.");
			exit() ;
		}
		channel = optionalLocalChannel.get();
		
		try {
			channel.queueDeclare(responceQueue, true, false, false, null);
			
			channel.queueDeclare(downstreamQueue, true, false, false, null);
			
			channel.exchangeDeclare(directExchange, "direct", true, false, null);
						
			DeliverCallback responceQueueCallback = (consumerTag, delivery) -> {
				
				RabbitmqCommandMessage<?> msg = (RabbitmqCommandMessage<?>) SerializationUtils.deserialize(delivery.getBody());
				commands.get(msg.getCommand()).accept(msg);
			};
			channel.basicConsume(responceQueue, true, responceQueueCallback, consumerTag -> { });
			
			
		} catch (IOException e) {
			logger.error("Error! IO Exception while declearing queue:  " + responceQueue + " with message: " + e.getMessage());
			exit();
		}
		

	}

    public static void main(String[] args) throws IOException, TimeoutException {
    	if (args.length > 0 && args[0].endsWith(".properties")) {
    		CabinetDownstream app = new CabinetDownstream( args[0] );
			System.out.println(app.getGreeting());
			app.run();

		} else {
			System.out.println("Usage: java -jar /path/to/mibs-cabinet-agent-all.jar /path/to/application.properties");
			exit();
		}
        
    }
}
