/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package mibs.init.cabinet;



import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Base64;
import java.util.Optional;
import java.util.concurrent.TimeoutException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.SerializationUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.DeliverCallback;


public class CabinetDownstream extends MessageHandler{
	
	private static final Logger logger = LogManager.getLogger(CabinetDownstream.class.getName());
	private static final int PORT=5672; 
	public CabinetDownstream(String conf) {
		super( conf );
	}
	
	public String getGreeting() {
        return "Hello world.";
    }
	private Optional<Channel> connectToRabbit(String host, String login, String password) {
		ConnectionFactory factory = new ConnectionFactory();
		factory.setHost( host );
		factory.setUsername( login );
		factory.setPassword( password );
		factory.setPort(PORT);
	
		Connection connection;
		Channel channel = null;
		try {
			connection = factory.newConnection();
			channel = connection.createChannel();
		
		} catch (IOException e) {
			logger.error("Error! IO Exception with message: " + e.getMessage());
			exit();
		} catch (TimeoutException e) {
			logger.error("Error! Timeout Exception with message: " + e.getMessage());
			exit();
		}

		return channel != null ? Optional.of(channel) : Optional.empty();

	}
	private void run() {
		Optional<Channel> optionalLocalChannel = connectToRabbit( rabbitmqHost, rabbitmqLogin, rabbitmqPassword );
		if (!optionalLocalChannel.isPresent()) {
			logger.error("Error! Fail to make connection to local rabbitmq.");
			exit() ;
		}
		channel = optionalLocalChannel.get();
		
		try {
			channel.queueDeclare(responceQueue, true, false, false, null);
			
			channel.queueDeclare(downstreamQueue, true, false, false, null);
			
			channel.exchangeDeclare(directExchange, "direct", true, false, null);
						
			DeliverCallback responceQueueCallback = (consumerTag, delivery) -> {
				
				RabbitmqCommandMessage<?> msg = (RabbitmqCommandMessage<?>) SerializationUtils.deserialize(delivery.getBody());
				commands.get(msg.getCommand()).accept(msg);
			};
			DeliverCallback downStreamCallback = (consumerTag, delivery) -> {
				
				RabbitmqDicomMessage dicomMessage = (RabbitmqDicomMessage) SerializationUtils.deserialize(delivery.getBody());
				
				String _path = dicomPath + "/" + dicomMessage.getExplorationID();
				Files.createDirectories( Paths.get(_path) );
				String fileName = _path + "/" + dicomMessage.getFileName();
				//FileUtils.writeByteArrayToFile(new File(fileName), dicomMessage.getPayload());
				
				byte[] buffer = new byte[1024];
				InputStream targetStream = new ByteArrayInputStream(dicomMessage.getPayload());
				 
				ZipInputStream zis = new ZipInputStream( targetStream );
				ZipEntry zipEntry = zis.getNextEntry();
				while (zipEntry != null) {
			            File newFile = newFile( new File(_path),  zipEntry);
			            FileOutputStream fos = new FileOutputStream(newFile);
			        	IOUtils.copy( zis, fos );
			   
			            fos.close();
			            zipEntry = zis.getNextEntry();
			        }
			        zis.closeEntry();
			        zis.close();
				System.out.println(fileName);
				
				
			};
			
			
			channel.basicConsume(responceQueue, true, responceQueueCallback, consumerTag -> { });
			
			channel.basicConsume(downstreamQueue, true, downStreamCallback, consumerTag -> { });
			
		} catch (IOException e) {
			logger.error("Error! IO Exception while declearing queue:  " + responceQueue + " with message: " + e.getMessage());
			exit();
		}
		

	}
	private  File newFile(File destinationDir, ZipEntry zipEntry) throws IOException {
	        File destFile = new File(destinationDir, zipEntry.getName());
	         
	        String destDirPath = destinationDir.getCanonicalPath();
	        String destFilePath = destFile.getCanonicalPath();
	         
	        if (!destFilePath.startsWith(destDirPath + File.separator)) {
	            throw new IOException("Entry is outside of the target dir: " + zipEntry.getName());
	        }
	         
	        return destFile;
	    }
    public static void main(String[] args) throws IOException, TimeoutException {
    	if (args.length > 0 && args[0].endsWith(".properties")) {
    		CabinetDownstream app = new CabinetDownstream( args[0] );
			System.out.println(app.getGreeting());
			app.run();

		} else {
			System.out.println("Usage: java -jar /path/to/mibs-cabinet-agent-all.jar /path/to/application.properties");
			exit();
		}
        
    }
}
